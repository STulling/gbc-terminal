# TODO

- [x] Implement a basic ROM loader
- [x] Get familiar with the GBC architecture
- [x] Work on basic CPU emulation
- [x] Get basic GUI up and running
- [x] Work on I/O emulation
- [x] Figure out which data to render to GUI
- [x] Debug the bad BG rendering using BGB as a comparison
- [x] Look into bad instruction in CPU test
    - [x] Use BGB to compare the flow
- [x] Look into inconsistent rendering
- [x] Migrate to software rendering
- [ ] ~~Move debugger into CPU~~
    - [ ] ~~Wrap all memory operations to be able to break on reads/writes in debugger~~
    - [ ] Not possible: we would not be able to pass the `Cpu` into the `Debugger`
- [x] Implement timer
- [x] Individual tests that are failing: 1-4, 11
    - [x] Test 1
        - [x] Bad check in add case... see: https://forums.nesdev.com/viewtopic.php?t=15944
    - [x] Test 2
        - [x] Fix: Implement CPU timer
    - [x] Test 3
        - [x] Fix: 16-bit SP/HL imm8 instructions use 8-bit carry and half-carry rules
    - [x] Test 4
        - [x] Fix: faulty half-carry logic for ADC and SBC
    - [x] Test 9
        - [x] Fix 1: Flags not updated for CPL, CCF, and SCF
        - [x] Fix 2: Added the rotate A (non-CB) instruction variants
    - [x] Test 11
        - [x] Fix 1: SWAP (HL) was reading from SP
        - [x] Fix 2: DAA (above)
- [x] Narrow down bug with instr_timing test
    - [x] Break at 0xC352
    - [x] `ret` at 0xC355 is never hit -- somewhere in between, the ROM is reset (?)
    - [x] Fix: turned out that the size for `LdMemCA` was incorrect...
- [x] Get regular OAM DMA working
    - Wiki on how OAM DMA works: https://gbdev.gg8.se/wiki/articles/OAM_DMA_tutorial
- [x] Basic window rendering
- [x] Get sprite rendering working
    - [x] Find good test ROM (Dr. Mario and Tetris)
- [x] Fix sprite overlap rendering
    - [x] Get the first 10 sprites in the line
        - [x] CGB: in OAM order
        - [x] DMG: in x-pos order
    - [x] Map these into sprite objects for simpler manipulation (?)
    - [x] Pass the list of sprites to each sprite pixel fetch call
    - [x] If pixel has color index 0, try the next sprite in priority order
- [x] Buffer up serial writes and expose as API on `Gameboy`
    - [x] This way, we can run tests in-line w/o calling into the CLI
- [x] Add option to load boot ROM (cartridge must be present)
- [x] Resizeable and scalable window
- [x] Fix partial sprite rendering at boundaries
    - [x] For example, in Kirby, moving Kirby to the top of the screen leads to it disappearing partially
- [x] Get OAM HDMA working
- [x] Get MBC5 controller working
- [x] Implement HDMA
- [x] Speed change might need to be handled explicitly
- [x] Save state support
    - [x] CPU: serialize as-is w/ register file
    - [x] Memory: serialize as-is
    - [x] Controller: serialize everything except the ROM and cartridge RAM
        - [x] Load the ROM from the cartridge
        - [x] If the cartridge has battery-backed RAM, create the backing file on save state load
    - [x] PPU: serialize as-is, including the frame buffer
    - [x] Timer: serialize as-is
    - [x] DMA: as-is
- [ ] Get MBC3 controller working
- [ ] Implement RTC logic for relevant MBCs
- [ ] WASM build
   - [ ] Identify areas where we will need conditional compilation
   - [ ] Get a basic WASM build working for the lib
   - [ ] Simple example of emulator running in JS (no rendering)
- [ ] FPS counter
    - [x] Static linking SDL2 TTF library does not seem to work on Windows
    - [ ] Find an alternative approach
- [ ] Split instruction handling into steps and allow all other peripherals to advance (interrupts, timer, PPU, sound, etc.)
    - [ ] For example, if the arg. is in memory, fetch the arg and return control back to the core Gameboy loop. On next CPU step, execute the instruction.
- [ ] Add basic logging throughout
- [ ] Get correct serial timing for interrupt handling
- [ ] Implement pixel FIFO
    - [ ] Look into dot clock pauses: https://gbdev.io/pandocs/#properties-of-stat-modes
